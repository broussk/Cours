/*
 * Copyright University of Reims Champagne-Ardenne
 * Authors: Emmanuel PLUOT, Gaetan RUBEZ, Jean-Charles-BOISSON and Eric HENON
 * Contributors: Hassan Khartabil, Corentin Lefebvre, Julia Contreras-Garcia
 * (24/07/2017)
 *
 * jean-charles.boisson@univ-reims.fr, eric.henon@univ-reims.fr
 *
 * This software is a computer program whose purpose is to 
 * detect and prepare the plot of molecular interactions
 * from electron density and IGM reference using promolecular
 * electron density.
 *
 * This software is governed by the CeCILL-C license under French law and
 * abiding by the rules of distribution of free software.  You can  use, 
 * modify and/ or redistribute the software under the terms of the CeCILL-C
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info". 
 *
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability. 
 *
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or 
 * data to be ensured and,  more generally, to use and operate it in the 
 * same conditions as regards security. 
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-C license and that you accept its terms.
 *
 * */

/**
* \file output.cpp
* \brief files writing functions.
* \author Gaetan & Emmanuel 
*/

#include<fstream>
#include<sstream>
#include<cstdio>
#include<algorithm>
#ifdef WINDOWS
    #include<direct.h>
    #include<windows.h>
    #define getDir _getcwd
#else
    #include<unistd.h>
    #define getDir getcwd
 #endif

#include"output.h"


using namespace std;

#define INDEX (k*data->getNbSteps(0)*data->getNbSteps(1)+j*data->getNbSteps(0)+i)


/**
 * \fn void outCube(int cubeType, param_t * params, ProgData * data, PREC * cubeRho, PREC * cube)
 * \brief Writes down the given cube and some parameters to help interprete it
 * \param cubeType : the type of the cube
 * \param params : the parameters read at the beginning of the program
 * \param data : the data received at the beginning of the program
 * \param cubeRho : the cubeRho processed during the program
 * \param cube : the cube itself
*/
void outCube(int cubeType, param_t * params, ProgData * data, PREC * cubeRho, PREC * cube){

        /* function dedicated to print a cube file for dgInter and dgIntra descriptors only */
	
	/* Building filename */
	ostringstream os;
	os << params->outputName << "-" << CUBE_NAMES[cubeType] << ".cube";
	
	/* Opening writing stream */
	ofstream writer(os.str().c_str());
    
	/* Setting stream precision to 6 numbers */
	writer << fixed << setprecision(6) << CUBE_NAMES[cubeType] + " cube" << endl << "Generated by IGMPlot" << endl;

       /* determining which kind of cube, to set the correct cutplotIGM	 */
        PREC EDThreshold(0.2f);
        if (CUBE_NAMES[cubeType]== "dgIntra") {
            EDThreshold = params->cutplotIGM[0] ;
        }
        else if (CUBE_NAMES[cubeType]== "dgInter") {
            EDThreshold = params->cutplotIGM[1] ;
        }
        else { EDThreshold = params->cutplotIGM[0] ;}


	
	/* Writing number of atom and min coordinates */
	writer << data->getNbAtom() << " " << data->getMinCoord(0) << " " << data->getMinCoord(1) << " " << data->getMinCoord(2) << endl;
	
	/* Writing steps and increments by axis */
	writer << data->getNbSteps(0) 	<< 	" " 					<<	params->increments[0]	<<	" 0.000000 0.000000" 	<< endl;
	writer << data->getNbSteps(1)	<<	" 0.000000 " 			<< 	params->increments[1] 	<< " 0.000000" 				<< endl;
	writer << data->getNbSteps(2)	<<	" 0.000000 0.000000 " 	<< 	params->increments[2] 								<< endl;

	/* Looping through all atoms  */
    for( int i(0) ; i < data->getNbAtom() ; ++i ){
		
		/* Writing both type and coordinates for each atom */
		writer << data->atomTypes[i] + 1 << " 0.0 " << data->atomPositions.xValues[i] << " " << data->atomPositions.yValues[i] << " " << data->atomPositions.zValues[i] << " " << endl;

	}
	
	/* Writing next values with scientific convention */
	writer << fixed << scientific;
	
	/* Index value initilization */
	int index(0);
	
	/* Looping over the first axis */
    for( int i(0) ; i < data->getNbSteps(0) ; ++i ){
		
		/* Looping over the second axis */
		for( int j(0) ; j < data->getNbSteps(1) ; ++j ){
			
			/* Looping over the third axis */
			for( int k(0) ; k < data->getNbSteps(2) ; ++k ){
				
				/* Writing value (those inside plots) */
				writer << ( fabs(cubeRho[INDEX]) > EDThreshold ? 0.f : cube[INDEX] ) << " ";
				
				
				/* Updating index */
				++index;
				
			}
			
			writer << endl;
			
		}
		
		writer << endl;

	}

	/* Closing writing stream */
    writer.close();
}

/**
 * \fn void outCubeRDG(param_t * params, ProgData * data, PREC * cube, PREC * rho)
 * \brief Writes down the given RDG cube and some parameters to help interprete it
 * \param params : the parameters read at the beginning of the program
 * \param data : the data received at the beginning of the program
 * \param cube : the cube itself
 * \param rho : the density values
*/
void outCubeRDG(param_t * params, ProgData * data, PREC * cube, PREC * rho, bool * shouldPrint){

        shouldPrint[0] = shouldPrint[0];	
	/* Building filename */
	ostringstream os;
	os << params->outputName << "-RDG.cube";
	
	/* Opening writing stream */
	ofstream writer(os.str().c_str());
    
	/* Setting stream precision to 6 numbers */
	writer << fixed << setprecision(6) << "RDG Cube" << endl << "Generated by IGMPlot" << endl;
	
    
	/* Writing number of atom and min coordinates */
	writer << data->getNbAtom() << " " << data->getMinCoord(0) << " " << data->getMinCoord(1) << " " << data->getMinCoord(2) << endl;
	
	/* Writing steps and increments by axis */
	writer << data->getNbSteps(0) 	<< 	" " 					<<	params->increments[0]	<<	" 0.000000 0.000000" 	<< endl;
	writer << data->getNbSteps(1)	<<	" 0.000000 " 			<< 	params->increments[1] 	<< " 0.000000" 				<< endl;
	writer << data->getNbSteps(2)	<<	" 0.000000 0.000000 " 	<< 	params->increments[2] 								<< endl;

	/* Looping through all atoms  */
    for( int i(0) ; i < data->getNbAtom() ; ++i ){
		
		/* Writing both type and coordinates for each atom */
		writer << data->atomTypes[i] + 1 << " 0.0 " << data->atomPositions.xValues[i] << " " << data->atomPositions.yValues[i] << " " << data->atomPositions.zValues[i] << " " << endl;

	}
	rho[0]=rho[0];
	
	/* Writing next values with scientific convention */
	writer << scientific;
	
	/* Index value initilization */
	int index(0);
	
	/* Looping over the first axis */
    for( int i(0) ; i < data->getNbSteps(0) ; ++i ){
		
		/* Looping over the second axis */
		for( int j(0) ; j < data->getNbSteps(1) ; ++j ){
			
			/* Looping over the third axis */
			for( int k(0) ; k < data->getNbSteps(2) ; ++k ){
				
				/* Writing value  */
				writer << ( fabs(rho[INDEX]) > params->cutplot[0] || !shouldPrint[INDEX] ? 100.f : cube[INDEX] ) << " ";
				 
				/* Updating index */
				++index;
				
			}
			
			writer << endl;
			
		}
		
		writer << endl;

	}

	/* Closing writing stream */
    writer.close();

}

/**
 * \fn void outCubeRho(param_t * params, ProgData * data, PREC * cube)
 * \brief Writes down the given Rho cube and some parameters to help interprete it
 * \param params : the parameters read at the beginning of the program
 * \param data : the data received at the beginning of the program
 * \param cube : the cube itself
*/
void outCubeRho(param_t * params, ProgData * data, PREC * cube){
	
	/* Building filename */
	ostringstream os;
	os << params->outputName << "-dens.cube";
	
	/* Opening writing stream */
	ofstream writer(os.str().c_str());
    
	/* Setting stream precision to 6 numbers */
	writer << fixed << setprecision(6) << "Electron density Cube" << endl << "Generated by IGMPlot" << endl ;
	
    
	/* Writing number of atom and min coordinates */
	writer << data->getNbAtom() << " " << data->getMinCoord(0) << " " << data->getMinCoord(1) << " " << data->getMinCoord(2) << endl;
	
	/* Writing steps and increments by axis */
	writer << data->getNbSteps(0) 	<< 	" " 					<<	params->increments[0]	<<	" 0.000000 0.000000" 	<< endl;
	writer << data->getNbSteps(1)	<<	" 0.000000 " 			<< 	params->increments[1] 	<< " 0.000000" 				<< endl;
	writer << data->getNbSteps(2)	<<	" 0.000000 0.000000 " 	<< 	params->increments[2] 								<< endl;

	/* Looping through all atoms  */
    for( int i(0) ; i < data->getNbAtom() ; ++i ){
		
		/* Writing both type and coordinates for each atom */
		writer << data->atomTypes[i] + 1 << " 0.0 " << data->atomPositions.xValues[i] << " " << data->atomPositions.yValues[i] << " " << data->atomPositions.zValues[i] << " " << endl;

	}
	
	/* Writing next values with scientific convention */
	writer << scientific;
	
	/* Index value initilization */
	int index(0);
	
	/* Looping over the first axis */
    for( int i(0) ; i < data->getNbSteps(0) ; ++i ){
		
		/* Looping over the second axis */
		for( int j(0) ; j < data->getNbSteps(1) ; ++j ){
			
			/* Looping over the third axis */
			for( int k(0) ; k < data->getNbSteps(2) ; ++k ){
				
				/* Writing value  */
				writer << cube[INDEX] << " ";
				 
				/* Updating index */
				++index;
				
			}
			
			writer << endl;
			
		}
		
		writer << endl;

	}

	/* Closing writing stream */
    writer.close();

}

/**
 * \fn void outDat(param_t * params, ProgData * data, Results&	results)
 * \brief Writes down the given Rho and RDG cubes
 * \param params : the parameters read at the beginning of the program
 * \param data : the data received at the beginning of the program
 * \param results : the process results
*/
void outDat(param_t * params, ProgData * data, Results&	results){
	
	/* Gathering pointers */
	PREC * cubeRho		= results.get(TYPE_RHO);
	PREC * cubeRDG		= results.get(TYPE_RDG);
	PREC * cubedgIntra  = results.get(TYPE_DELTA_G_INTRA);
	PREC * cubedgInter	= results.get(TYPE_DELTA_G_INTER);
	bool * shouldPrint	= results.getShouldPrint();
	
	/* Building filename */
	ostringstream os;
	os << params->outputName << "-nci.dat";
	
	/* Opening writing stream */
	ofstream writerNCI(os.str().c_str());
	
	/* Building second filename */
	os.clear();
	os.str("");
	os << params->outputName << "-igm.dat";
	
	/* Opening writing stream */
	ofstream writerIGM(os.str().c_str());
		
	/* Setting stream precision to 6 numbers */
	writerNCI << fixed << setprecision(6);
	writerIGM << fixed << setprecision(6);
	
	
	/* Writing next values with scientific convention */
	writerNCI << scientific;
	writerIGM << scientific;
	

	/* Writing header */
	writerNCI << "   RHO            RDG" << endl;
	writerIGM << "   RHO            RDG         dg_intra        dg_inter" << endl;
	
	/* Looping over the first axis */
    for( int i(0) ; i < data->getNbSteps(0) ; ++i ){
		
		/* Looping over the second axis */
		for( int j(0) ; j < data->getNbSteps(1) ; ++j ){
			
			/* Looping over the third axis */
			for( int k(0) ; k < data->getNbSteps(2) ; ++k ){

				/* Checks if the value is in the cutoffs */
				if (cubeRho[INDEX] >= -params->cutoffs[0] && cubeRho[INDEX] <= params->cutoffs[0] && cubeRDG[INDEX] <= params->cutoffs[1]){
					
					/* Writing value NCI */
					if(shouldPrint[INDEX]) writerNCI << cubeRho[INDEX] << "  " << cubeRDG[INDEX] << endl;
				
					/* Writing value IGM */
					writerIGM << cubeRho[INDEX] << "  " << cubeRDG[INDEX] << "  " << cubedgIntra[INDEX] << "  " << cubedgInter[INDEX] <<endl;
				 
				 
				}
			 
				
			}
			
		}

	}

	/* Closing writing streams */
    writerNCI.close();
    writerIGM.close();
}

/**
 * \fn void outPercent(param_t * params, Results &results)
 * \brief Writes down the percentage participation for each atom
 * \param params : the parameters read at the beginning of the program
 * \param results : the results' values
 * \param total : the sum of dg inter's values
*/
void outPercent(param_t * params, Results &results, PREC total){
	
	
	/* Building filename */
	ostringstream os;
	os << params->outputName << "-percent.dat";
	
	/* Opening writing stream */
	ofstream writer(os.str().c_str());
    
	/* Setting stream precision to 6 numbers */
	writer << fixed << setprecision(6);

	/* Looping through all atoms */
    for( int i(0) ; i < results.getNbAtom() ; ++i ){
		
		/* Writing participation percentage for each atom */
		writer << ( ( CAST_PREC(results.get(i, Results::DGSIE)) / total ) * 100.f ) << endl;

	}
	
	/* Closing writing stream */
    writer.close();
}

/**
 * \fn string getWorkPath()
 * \brief returns a string with the current working path
 * \return the current path of the execution
*/
string getWorkPath(){
	char buffer[FILENAME_MAX];
	string dir(getDir(buffer, FILENAME_MAX));
	dir += "/";

	//printf("Working   Path: %s\n",dir.c_str());

	return dir;
}

/**
 * \fn string getExecPath()
 * \brief returns a string with the current path of the execution
 * \return the current path of the execution
*/
string getExecPath(){
	
	const int LEN = 4096;
	char buffer[LEN];
	
	ssize_t buffer_real_length=-1;
	
	#ifdef WINDOWS
		GetModuleFileName(NULL, buffer, LEN);
	#else
		char tmp[32];
		sprintf(tmp, "/proc/%d/exe", getpid());
		buffer_real_length=readlink(tmp, buffer, LEN);
	#endif

	if(buffer_real_length == -1)
	  {
	    cerr << endl;
	    cerr << "[ERROR] No value has beend saved in buffer during readlink in getExecPath" << endl;
	    cerr << "[ERROR] The program will now exit." << endl;
	    exit(EXIT_FAILURE);
	  }

	string dir(buffer);
	dir = dir.substr(0, dir.find_last_of("\\/")+1);

	//printf("\nExecution Path: %s\n",dir.c_str());
	
	return dir;
	
}

/**
 * \fn void outVMD(param_t * params, ProgData * data, PREC max)
 * \brief Writes down the VM script for visualisation
 * \param params : the parameters read at the beginning of the program
 * \param data : the program's data
 * \param max : the maximum percent found
*/
void outVMD(param_t * params, ProgData * data, PREC max){
	
  /* Getting current paths */
  //string currPath = getExecPath();
  string currWork = getWorkPath();
  //cout << currPath << endl << currWork << endl;
  //


  /**************************************/
  /*******COMPLEX FILE GENERATION********/
  /**************************************/


  /* Opening molecule related streams */
  ifstream molA(params->molAFileName);
  ifstream molB(params->molBFileName);
  ofstream comp(params->outputName+"-complex.xyz");
	

  if(molA.good() && comp.good() && (  ( !params->molBFileName.empty() && molB.good() ) || params->molBFileName.empty()  )  )
    {
	
      { // Printing number of atoms
			
	int temp, total(0);
	
	/* Getting number of atom */
	molA >> temp;
	total+=temp;
	if (!params->molBFileName.empty())
	  {
	    molB >> temp;
	    total+=temp;
	  }
				
	comp << "  " << total << endl << endl;
				
				
	/* Ignoring comment lines */
	molA.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
	molA.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
	if (!params->molBFileName.empty())
	  {
	    molB.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
	    molB.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
	  }
			
      } // end of Printing number of atoms
		
      { // Printing molecules' atoms' values
		
	string symbol;
	double posX, posY, posZ;
	
	/* Handling molecule A */
	while(molA >> symbol)
	  {
			
	    /* Printing atom's symbol */
	    comp << " " << symbol << "        ";
	    
	    /* Getting atom's position */
	    molA >> posX;
	    molA >> posY;
	    molA >> posZ;
	    
	    /* Printing atom's position */
	    comp << posX << "        ";
	    comp << posY << "        ";
	    comp << posZ << endl;
	    
	  }
			
			
	/* Handling molecule B if it is not empty */
	if (!params->molBFileName.empty())
	  {
	    while(molB >> symbol)
	      {
			
		/* Printing atom's symbol */
		comp << " " << symbol << "        ";
		
		/* Getting atom's position */
		molB >> posX;
		molB >> posY;
		molB >> posZ;
		
		/* Printing atom's position */
		comp << posX << "        ";
		comp << posY << "        ";
		comp << posZ << endl;
		
	      }  // end of while(molB >> symbol){
	  } // end of if (!params->molBFileName.empty())
	
      } // end of Printing molecules' atoms' values
		
		
      
    }
  else
    {
      
      cerr << "[ERROR] Problem while opening streams." << endl;
      cerr << "[ERROR] Make sure the program has the necessary rights." << endl;
      cerr << "[ERROR] The program will now exit." << endl;
      exit(EXIT_FAILURE);	
    }
	
  /* Closing streams */
  molA.close();
  molB.close();
  comp.close();	
	
  /**************************************/
  /********VMD SCRIPT GENERATION*********/
  /**************************************/

  string rep[SIZE_KEYWORDS];
  ostringstream oss;
  oss << currWork << params->outputName << "-dgInter.cube";
  rep[DGINTER]= oss.str();
  oss.str("");

  oss << currWork << params->outputName << "-dgIntra.cube";
  rep[DGINTRA]= oss.str();
  oss.str("");

  oss << currWork << params->outputName << "-dens.cube";
  rep[DENS] = oss.str();
  oss.str("");

  oss << currWork  << params->outputName <<  "-RDG.cube";
  rep[RDG]  = oss.str();
  oss.str("");

  oss << currWork <<  params->outputName << "-percent.dat";
  rep[PERCENT] = oss.str();
  oss.str("");

  oss << currWork << params->outputName << "-complex.xyz";
  rep[COMPLEX] = oss.str();
  oss.str("");

  oss << params->cutplot[0];
  rep[CUTPLOT1] = oss.str();
  oss.str("");

  oss << params->cutplot[1];
  rep[CUTPLOT2] = oss.str();
  oss.str("");
  
  oss << params->cutplotIGM[0];
  rep[CUTPLOTIGM1] = oss.str();
  oss.str("");

  oss << params->cutplotIGM[1];
  rep[CUTPLOTIGM2] = oss.str();
  oss.str("");

  oss << params->vmdcolrangIGM[0];
  rep[VMDCOLRANGIGM1] = oss.str();
  oss.str("");

  oss << params->vmdcolrangIGM[1];
  rep[VMDCOLRANGIGM2] = oss.str();
  oss.str("");

  oss << params->cutoffs[0];
  rep[CUTOFFS1] = oss.str();
  oss.str("");

  oss << params->cutoffs[1];
  rep[CUTOFFS2] = oss.str();
  oss.str("");

  oss << data->getNbAtomMolA();
  rep[FIRST_PROT_INDEX] = oss.str();
  oss.str("");

  oss << data->getNbAtom() -1;
  rep[LAST_COMPLEX_INDEX] = oss.str();
  oss.str("");

  oss << data->getNbAtomMolA() -1;
  rep[LAST_LIG_INDEX] = oss.str();
  oss.str("");

  oss << max;
  rep[MAX_PERCENT] 	= oss.str();
  oss.str("");

  generateVMDatContrFile(rep);
  generateVMDigmFile(rep);
  generateVMDnciFile(rep);
  
  /*for(int i(0) ;  i < ( params->outputType>=4 ? (params->outputType <5 ? 1 : SCRIPT_NAMES_LENGTH) : 0 ); ++i )
    {
  */
      
      /* Opening streams */
      /*ifstream in(currPath + SCRIPT_NAMES[i] + ".tvmd");
      		
      if( !in.good() )
	{
	  cerr << endl;
	  cerr << "[ERROR] Could not open file " << currPath << SCRIPT_NAMES[i] << ".tvmd" << endl;
	  cerr << "[ERROR] Make sure the script are available to the program and the program has necessary rights." << endl;
	  cerr << "[ERROR] The program will now exit." << endl;
	  exit(EXIT_FAILURE);
	}

      ofstream out(SCRIPT_NAMES[i] + ".vmd");
		
      if( !out.good() )
	{
	  cerr << endl;
	  cerr << "[ERROR] Could not open file " << SCRIPT_NAMES[i] << ".vmd" << endl;
	  cerr << "[ERROR] Make sure the script are available to the program and the program has necessary rights." << endl;
	  cerr << "[ERROR] The program will now exit." << endl;
	  exit(EXIT_FAILURE);
	  }*/

      
      
      /*string read;
      while( getline(in,read) )
      {*/
	  /* Getting line */
      /* stringstream os;
	 os << read;*/
	    
	  /* Replacements */
	  /*ostringstream rep[SIZE_KEYWORDS];
	  rep[DGINTER] 			<< currWork + params->outputName + "-dgInter.cube";
	  rep[DGINTRA] 			<< currWork + params->outputName + "-dgIntra.cube";
	  rep[DENS] 				<< currWork + params->outputName + "-dens.cube";
	  rep[RDG]                                << currWork + params->outputName + "-RDG.cube";
	  rep[PERCENT] 			<< currWork + params->outputName + "-percent.dat";
	  rep[COMPLEX] 			<< currWork + params->outputName + "-complex.xyz";
	  rep[CUTPLOT1] 			<< params->cutplot[0];
	  rep[CUTPLOT2] 			<< params->cutplot[1];
	  rep[CUTPLOTIGM1]                << params->cutplotIGM[0];
	  rep[CUTPLOTIGM2]                << params->cutplotIGM[1];
	  rep[VMDCOLRANGIGM1]             << params->vmdcolrangIGM[0];
	  rep[VMDCOLRANGIGM2]             << params->vmdcolrangIGM[1];
	  rep[CUTOFFS1]			<< params->cutoffs[0];
	  rep[CUTOFFS2]			<< params->cutoffs[1];
	  rep[FIRST_PROT_INDEX] 	<< data->getNbAtomMolA();
	  rep[LAST_COMPLEX_INDEX] << data->getNbAtom() -1;
	  rep[LAST_LIG_INDEX] 	<< data->getNbAtomMolA() -1;
	  rep[MAX_PERCENT] 		<< max;*/
	    
	    /* Decomposing line */
      /*while(os >> read)
	{*/
	      
	      /* Which keyword */
      /*   for(int j(0) ; j < SIZE_KEYWORDS ; ++j)
		{
		  size_t pos;
		  if( (pos = read.find(KEYWORDS[j])) != std::string::npos)
		    {
		      read.replace(pos, KEYWORDS[j].length(), rep[j].str());
		    }
		}
	      out << read << " ";
	    }
	  out << endl;
	}*/
	  
      /* Closing streams */
      /*in.close();
      out.close();
      }*/
}

