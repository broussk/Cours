#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <time.h>

/**
 * Énumération définissant les états des processus
 */
enum State{CANDIDAT, BATTU, ELU};

/**
 * Structure représentant un processus
 */
typedef struct Process{
    enum State state; //son état
    int id; //son id
    int pid; //son pid
}Process;

/**
 * Convertis un State en chaîne de caractères
 * @param state le state
 * @return une chaîne de caractères
 */
char *stateToString(enum State state){
    if(state == CANDIDAT)
        return "Candidat";
    else if (state == BATTU)
        return "Battu";
    else
        return "Elu";
}

/**
 * Affiche un tableau de processus
 * @param process tableau de processus
 * @param n nombre de processus
 */
void printProcess(Process *process, int n){
    for(int i=0;i<n;i++){
        printf("-Processus #%d (id = %d, PID = %d) : %s\n", i, process[i].id, process[i].pid,
               stateToString(process[i].state));
    }
}

/**
 * Méthode qui génère un ID pour un processus
 * @param process le tableau de processus
 * @param i l'emplacement du processus dans le tableau
 * @param n le nombre de processus
 */
void generateID(Process *process, int i, int n){
    srand(time(NULL) * i ^ n);
    process[i].id= rand() % n + 1;
}

/**
 * Méthode qui permet de recherche le plus petit ID parmis tous les processsu candidats
 * @param process le tableau de processus
 * @param n le nombre de processus
 */
int getMinimumID(Process *process, int n){
    int min = n;
    for(int i = 0; i < n; i++){
        if(process[i].id < min){
            min=process[i].id;
        }
    }
    return min;
}

/**
 * Permet de récupèrer les candidants restant après un tour d'élection
 * @param process les processus actuel
 * @param tmpProcess le nouveau tableau de processus canddiats
 * @param min l'id minimum
 * @param n nombre de processus actuel
 * @return int
 */
int getRemainCandidat(Process *process, Process *tmpProcess, int min, int n){
    int remaining = 0, pos = 0;
    for(int i = 0; i < n; i++){
        if(process[i].id != min){
            process[i].state= BATTU;
        }else{
            //On affecte les processus encore en jeu dans le nouveau tableau et incrémente le nombre de candidats restant
            tmpProcess[pos]=process[i];
            pos++;
            remaining++;
        }
    }
    return remaining;
}

/**
 * Permet de réaffecter un nouvel id aux processus candidats restant
 * @param process tableau de processus
 * @param n nombre de processus
 * @param remaining nombre de candidats restant
 */
void reallocationID(Process *process, int n, int remaining){
    for(int i = 0; i < n; i++){
        if(process[i].state == CANDIDAT){
            //génère le nouvel ID
            generateID(process, i, remaining);
            //affiche le processus avec son nouvel ID
            printf("-Processus #%d (id = %d, PID = %d) : %s\n", i, process[i].id, process[i].pid,stateToString(process[i].state));
        }
    }
}

/**
 * Permet de récupèrer le processus gagnant
 * @param process les processus candiats de départ
 * @param min l'id minimum
 * @param n le nombre de processus
 */
void getWinner(Process *process, int min, int n){
    for(int i = 0; i < n ; i++){
        if(process[i].id == min){
              process[i].state= ELU;
              printf("\n-------------------------------Gagnant----------------------------------\n");
              printf("Processus #%d (id = %d, PID = %d) : %s\n", i, process[i].id, process[i].pid,
                       stateToString(process[i].state));
              printf("------------------------------------------------------------------------\n");
      }
    }
}

/**
 * Méthode récursive qui lance l'élection
 * @param process le tableau de processus
 * @param n le nombre de processus candidat
 */
void runElection(Process *process, int n){
    int min, remaining;
    Process *tmpProcess;

    //Tant que l'élection n'est pas finie c-a-d qu'on n'a pas de gagnant
    tmpProcess = malloc(n*sizeof(Process));

    //On cherche le plus petit id présent dans le tableau des processus
    min = getMinimumID(process, n);

    //Ensuite, on supprime les processus battus, et on compte le nombre de processus encore en jeu
    remaining = getRemainCandidat(process, tmpProcess, min, n);

    //Si le nombre de candidats n'est pas égale à 1 c'est qu'il faut refaire une élection pour les déterminer
    if(remaining != 1){
        printf("=> Nouvelle election : \n");
        //On leur réaffecte un nouveau id pour les départager
        reallocationID(process, n, remaining);
        //On relance une élection
        runElection(process, n);
    }else{
        //Si on a un gagnant on coupe la boucle puis on l'affiche
        getWinner(process, min, n);
    }

    //On libère la mémoire du tableau temporaire pour prochain tour s'il y a
    free(tmpProcess);
}

int main (int argc,char **argv){
    //Permet d'avoir de tirage unique à chaque lancement
    srand(time(NULL));

    //Récupère la paramètre argv[1] de la commande
    //Nombre de processus candidats
    int nbProcesssus = atoi(argv[1]);

    //Tableau des processus candidats
    Process *process;

    //On vérifie qu'il y ait bien un paramètre de passé et qu'il n'est pas négatif
    if (argc < 2 || nbProcesssus <= 0) exit(1);
    else{
        pid_t pid;
        int i, p[nbProcesssus][2]; //tubes
        process = malloc(nbProcesssus * sizeof(Process)); //alloue en mémoire le tableau qui contiendra les processus

        //Création des tubes pour chaque processus
        for (i=0; i < nbProcesssus; ++i) pipe(p[i]);

        for (i=0; i < nbProcesssus; ++i){
            pid = fork();
            if (pid>0){
                generateID(process, i, nbProcesssus);
                process[i].pid = pid;
                process[i].state= CANDIDAT;
            }
                //Si on a pas de pid alors c'est processus fils
            else if (!pid){
                int in, out, data, j;
                //Temporisation sinon la boucle du pére se termine trop tôt
                sleep(1);

                //Recupère les tubes néscessaires
                in  = p[i][0];
                out = p[(i+1) % nbProcesssus][1];

                //Fermeture des tubes inutiles (non utilisés)
                for (j=0; j < nbProcesssus; j++){
                    if (p[j][0] != in)  close(p[j][0]);
                    if (p[j][1] != out) close(p[j][1]);
                }

                //Récupération PID
                data = (int)getpid();

                //Écrit dans le tube le pid puis on le ferme
                write(out,&data,sizeof data);
                close (out);

                //Récupération PID
                data = (int)getpid();
                //lit le pid présent dans le tube puis on le ferme
                read (in,&data,sizeof data);
                close (in);
                break;
            }
        }
        //pid != 0 -> pére, alors on fait des wait pour attendre les processus fils
        if (pid > 0){
            for (i=0; i < nbProcesssus; i++) wait(NULL);
            printf("------Candidats en jeu : -----\n");
            printProcess(process, nbProcesssus); //affiche les processus en jeu
            printf("-----Election : -----\n");
            runElection(process, nbProcesssus); //lance l'élection
        }
    }
    //On libère l'espace mémoire ou est stocké le tableau des processus candidat
    free(process);
    exit(0);
}
